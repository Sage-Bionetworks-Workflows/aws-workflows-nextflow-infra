AWSTemplateFormatVersion: "2010-09-09"
Description: >-
  Stack for provisioning the AWS resources needed for
  configuring compute environments in Nextflow Tower.

Parameters:
  S3ReadWriteAccessArns:
    Type: List<String>
    Default: ""
    Description: >-
      (Optional) List of IAM users and roles (strings) who
      should have read- and write-access to the S3 bucket.
      These ARNs will also have access to the configuration
      secret. You can provide role ARNs or assumed-role ARNs.

  S3ReadOnlyAccessArns:
    Type: List<String>
    Default: ""
    Description: >-
      (Optional) List of IAM users and roles (strings)
      who should only have read-access to the S3 bucket.
      These ARNs will also have access to the configuration
      secret. You can provide role ARNs or assumed-role ARNs.

  AllowSynapseIndexing:
    Type: String
    Description: Enabled to allow Synapse indexing, default is Enabled
    AllowedValues:
      - Enabled
      - Disabled
    Default: Enabled

  EnableDataLifeCycle:
    Type: String
    Description: >-
      Enabled to enable bucket lifecycle rule, default is Enabled
      Set to 'Enabled' if AllowSynapseIndexing is enabled.
    AllowedValues:
      - Enabled
      - Disabled
    Default: Enabled

  LifecycleDataTransition:
    Type: Number
    Description: >-
      Number of days until S3 objects are moved to LifecycleDataStorageClass.
      Set to '30' if AllowSynapseIndexing is enabled.
    Default: 30

  LifecycleDataStorageClass:
    Type: String
    Description: >-
      S3 bucket objects will transition into this storage class.
      Set to 'INTELLIGENT_TIERING' if AllowSynapseIndexing is enabled.
    AllowedValues:
      - DEEP_ARCHIVE
      - INTELLIGENT_TIERING
      - STANDARD_IA
      - ONEZONE_IA
      - GLACIER
    Default: INTELLIGENT_TIERING

  LifecycleDataExpiration:
    Type: Number
    Description: >-
      Number of days (from creation) when objects are deleted from S3.
      Disabled if AllowSynapseIndexing is enabled.
    Default: 183

  AccountAdminArns:
    Type: List<String>
    Description: >-
      List of IAM user and role ARNs (strings) who should have access to
      project-specific resources (e.g., private S3 bucket, KMS key, secrets).

  TemplateRootUrl:
    Type: String
    Description: URL of S3 bucket where templates are deployed
    ConstraintDescription: Must be a valid S3 HTTP URL

  TowerForgePolicyArn:
    Type: String
    Description: ARN for Tower Forge IAM policy

  TowerLaunchPolicyArn:
    Type: String
    Description: ARN for Tower Launch IAM policy

Conditions:
  HasS3ReadWriteAccessArns:
    !Not [!Equals [!Join [",", !Ref S3ReadWriteAccessArns], ""]]
  HasS3ReadOnlyAccessArns:
    !Not [!Equals [!Join [",", !Ref S3ReadOnlyAccessArns], ""]]
  SynapseIndexingEnabled: !Equals [!Ref AllowSynapseIndexing, "Enabled"]

Resources:
  TowerForgeServiceUser:
    Type: AWS::IAM::User

  TowerForgeServiceUserAccessKey:
    Type: AWS::IAM::AccessKey
    Properties:
      UserName: !Ref TowerForgeServiceUser

  TowerForgeServiceRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - !Ref TowerForgePolicyArn
        - !Ref TowerLaunchPolicyArn
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              AWS: !GetAtt TowerForgeServiceUser.Arn
          - Effect: Allow  # Do account admins really need to be able to assume this role? for debugging?
            Action: sts:AssumeRole
            Principal:
              AWS: !Ref AccountAdminArns 

  TowerForgeBatchHeadJobRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service:
                - ecs-tasks.amazonaws.com

  TowerForgeBatchWorkJobRole:
    Type: AWS::IAM::Role
    Properties:
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service:
                - ecs-tasks.amazonaws.com

  TowerForgeBatchHeadJobPolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: TowerForgeBucketAccessPolicy #This policy allows more actions and should be renamed
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: NextflowConfig
            Effect: Allow
            Action:
              - batch:DescribeJobQueues
              - batch:CancelJob
              - batch:SubmitJob
              - batch:ListJobs
              - batch:DescribeComputeEnvironments
              - batch:TerminateJob
              - batch:DescribeJobs
              - batch:RegisterJobDefinition
              - batch:DescribeJobDefinitions
              - ecs:DescribeContainerInstances
              - ecs:DescribeTasks
              - ec2:DescribeInstances
              - ec2:DescribeInstanceAttribute
              - ec2:DescribeInstanceTypes
              - ec2:DescribeInstanceStatus
            Resource: "*" #Should this be conditional on project resources only?
          - Sid: IAMConfig
            Effect: Allow
            Action:
              - iam:GetRole
              - iam:PassRole
            Resource: !GetAtt TowerForgeBatchWorkJobRole.Arn
      Roles:
        - !Ref TowerForgeBatchHeadJobRole

  EncryptionKeyStack:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Sub ${TemplateRootUrl}/KMS/kms-key.yaml
      TimeoutInMinutes: 5
      Parameters:
        AliasName: !Sub "alias/${AWS::StackName}-EncryptionKey"
        AdminPrincipalArns: !Join
          - ","
          - - !Sub "arn:aws:iam::${AWS::AccountId}:root"
            - !Join
              - ","
              - !Ref AccountAdminArns
        UserPrincipalArns: !Join
          - ","
          - - !Sub "arn:aws:iam::${AWS::AccountId}:root"
            - !GetAtt TowerForgeBatchHeadJobRole.Arn
            - !GetAtt TowerForgeBatchWorkJobRole.Arn
            - !GetAtt TowerForgeServiceRole.Arn
            - !Join
              - ","
              - !Ref AccountAdminArns
            - !If
              - HasS3ReadWriteAccessArns
              - !Join
                - ","
                - !Ref S3ReadWriteAccessArns
              - !Ref AWS::NoValue
            - !If
              - HasS3ReadOnlyAccessArns
              - !Join
                - ","
                - !Ref S3ReadOnlyAccessArns
              - !Ref AWS::NoValue
            - !If
              - SynapseIndexingEnabled
              - "arn:aws:iam::325565585839:root"
              - !Ref AWS::NoValue

  TowerBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-tower-bucket" #would it make sense to append project bucket names with a tenant name?
      OwnershipControls:
        Rules:
          - ObjectOwnership: BucketOwnerPreferred
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - BucketKeyEnabled: true
            ServerSideEncryptionByDefault:
              SSEAlgorithm: aws:kms
              KMSMasterKeyID: !GetAtt EncryptionKeyStack.Outputs.KeyArn
      LifecycleConfiguration:
        Rules:
        - !If
          - SynapseIndexingEnabled
          - Id: SynapseEnabledDataLifecycleRule
            Status: Enabled
            Transitions:
              - TransitionInDays: 30
                StorageClass: INTELLIGENT_TIERING
          - Id: UserDefinedDataLifecycleRule
            Status: !Ref EnableDataLifeCycle
            ExpirationInDays: !Ref LifecycleDataExpiration
            Transitions:
              - TransitionInDays: !Ref LifecycleDataTransition
                StorageClass: !Ref LifecycleDataStorageClass
      CorsConfiguration:
        CorsRules:
        - !If
          - SynapseIndexingEnabled
          - Id: SynapseCORSRule
            AllowedHeaders: ["*"]
            AllowedOrigins: ["*"]
            AllowedMethods: [GET, POST, PUT, HEAD]
            MaxAge: 3000
          - Id: NullCorsRule
            AllowedHeaders: [""]
            AllowedOrigins: [""]
            AllowedMethods: ["GET"]
            MaxAge: 0

  TowerBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref TowerBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: TowerForgeRoleS3Access
            Effect: Allow
            Principal:
              AWS:
                - !GetAtt TowerForgeServiceRole.Arn
                - !GetAtt TowerForgeBatchHeadJobRole.Arn
                - !GetAtt TowerForgeBatchWorkJobRole.Arn
            Action:
              - "s3:GetBucketLocation"
              - "s3:ListBucket"
              - "s3:GetObject"
              - "s3:PutObject"
              - "s3:PutObjectTagging"
              - "s3:DeleteObject"
              - "s3:*MultipartUpload*"
            Resource:
              - !Sub "arn:aws:s3:::${TowerBucket}"
              - !Sub "arn:aws:s3:::${TowerBucket}/*"
          - !If
            - HasS3ReadWriteAccessArns
            - Sid: GrantWriteAccessToS3ReadWriteAccessArns
              Effect: Allow
              Principal:
                AWS: !Ref S3ReadWriteAccessArns
              Action:
                - "s3:PutObject*"
              Condition:
                StringEquals:
                  s3:x-amz-acl: bucket-owner-full-control
              Resource:
                - !Sub "arn:aws:s3:::${TowerBucket}/*"
            - !Ref AWS::NoValue
          - !If
            - HasS3ReadWriteAccessArns
            - Sid: GrantRemainingAccessToS3ReadWriteAccessArns
              Effect: Allow
              Principal:
                AWS: !Ref S3ReadWriteAccessArns
              Action:
                - "s3:GetObject*"
                - "s3:DeleteObject*"
                - "s3:*MultipartUpload*"
                - "s3:ListBucket*"
                - "s3:GetBucketLocation"
              Resource:
                - !Sub "arn:aws:s3:::${TowerBucket}"
                - !Sub "arn:aws:s3:::${TowerBucket}/*"
            - !Ref AWS::NoValue
          - !If
            - HasS3ReadOnlyAccessArns
            - Sid: GrantReadAccessToS3ReadOnlyAccessArns
              Effect: Allow
              Principal:
                AWS: !Ref S3ReadOnlyAccessArns
              Action:
                - "s3:ListBucket*"
                - "s3:GetBucketLocation"
                - "s3:GetObject"
                - "s3:GetObjectAcl"
              Resource:
                - !Sub "arn:aws:s3:::${TowerBucket}"
                - !Sub "arn:aws:s3:::${TowerBucket}/*"
            - !Ref AWS::NoValue
          - !If
            - SynapseIndexingEnabled
            - Sid: GrantBucketReadAccessToSynapse
              Effect: Allow
              Principal:
                AWS: "arn:aws:iam::325565585839:root"  # Synapse Account
              Action:
                - "s3:ListBucket*"
                - "s3:GetBucketLocation"
              Resource:
                - !Sub "arn:aws:s3:::${TowerBucket}"
            - !Ref AWS::NoValue
          - !If
            - SynapseIndexingEnabled
            - Sid: GrantObjectReadAccessToSynapse
              Effect: Allow
              Principal:
                AWS: "arn:aws:iam::325565585839:root"  # Synapse Account
              Action:
                - "s3:GetObject*"
              Resource:
                - !Sub "arn:aws:s3:::${TowerBucket}/*"
            - !Ref AWS::NoValue

  TowerForgeServiceUserAccessKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: !Sub "AWS credentials for the ${TowerForgeServiceUser} IAM user"
      SecretString: !Sub >-
        {
          "aws_access_key_id":      "${TowerForgeServiceUserAccessKey}",
          "aws_secret_access_key":  "${TowerForgeServiceUserAccessKey.SecretAccessKey}"
        }
      KmsKeyId: !GetAtt EncryptionKeyStack.Outputs.Key

Outputs:
  S3ReadWriteAccessArns:
    Condition: HasS3ReadWriteAccessArns
    Value: !Join [ ",", !Ref S3ReadWriteAccessArns ]
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-S3ReadWriteAccessArns"

  S3ReadOnlyAccessArns:
    Condition: HasS3ReadOnlyAccessArns
    Value: !Join [ ",", !Ref S3ReadOnlyAccessArns ]
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-S3ReadOnlyAccessArns"

  TowerBucket:
    Value: !Ref TowerBucket
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerBucket"

  TowerBucketArn:
    Value: !GetAtt TowerBucket.Arn
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerBucketArn"

  TowerForgeServiceUser:
    Value: !Ref TowerForgeServiceUser
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeServiceUser"

  TowerForgeServiceUserArn:
    Value: !GetAtt TowerForgeServiceUser.Arn
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeServiceUserArn"

  TowerForgeServiceRole:
    Value: !Ref TowerForgeServiceRole
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeServiceRole"

  TowerForgeServiceRoleArn:
    Value: !GetAtt TowerForgeServiceRole.Arn
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeServiceRoleArn"

  TowerForgeBatchHeadJobRole:
    Value: !Ref TowerForgeBatchHeadJobRole
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeBatchHeadJobRole"

  TowerForgeBatchHeadJobRoleArn:
    Value: !GetAtt TowerForgeBatchHeadJobRole.Arn
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeBatchHeadJobRoleArn"

  TowerForgeBatchWorkJobRole:
    Value: !Ref TowerForgeBatchWorkJobRole
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeBatchWorkJobRole"

  TowerForgeBatchWorkJobRoleArn:
    Value: !GetAtt TowerForgeBatchWorkJobRole.Arn
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeBatchWorkJobRoleArn"

  TowerForgeServiceUserAccessKeySecret:
    Value: !Sub "${AWS::StackName}-TowerProjectConfiguration"
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeServiceUserAccessKeySecret"

  TowerForgeServiceUserAccessKeySecretArn:
    Value: !Ref TowerForgeServiceUserAccessKeySecret
    Export:
      Name: !Sub "${AWS::Region}-${AWS::StackName}-TowerForgeServiceUserAccessKeySecretArn"
